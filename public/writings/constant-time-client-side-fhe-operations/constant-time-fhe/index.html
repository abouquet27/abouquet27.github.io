<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><script defer language=javascript type=text/javascript src=/js/bundle.min.14549c76bbc96f0af1574b0259efd70e52908cd36fb4d14ed3d290a1b6479eae.js></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=https://github.com/abouquet27.png><title itemprop=name>Adrien's Dashbook - Constant-Time client-side FHE operations</title><meta property="og:title" content="Adrien's Dashbook - Constant-Time client-side FHE operations"><meta name=twitter:title content="Adrien's Dashbook - Constant-Time client-side FHE operations"><meta itemprop=name content="Adrien's Dashbook - Constant-Time client-side FHE operations"><meta name=application-name content="Adrien's Dashbook - Constant-Time client-side FHE operations"><meta property="og:site_name" content="Adrien's Dashbook"><meta name=description content="Master semester project @ SPRING Lab, EPFL"><meta itemprop=description content="Master semester project @ SPRING Lab, EPFL"><meta property="og:description" content="Master semester project @ SPRING Lab, EPFL"><meta name=twitter:description content="Master semester project @ SPRING Lab, EPFL"><base href=/writings/constant-time-client-side-fhe-operations/constant-time-fhe/><link rel=canonical href=/writings/constant-time-client-side-fhe-operations/constant-time-fhe/ itemprop=url><meta name=url content="/writings/constant-time-client-side-fhe-operations/constant-time-fhe/"><meta name=twitter:url content="/writings/constant-time-client-side-fhe-operations/constant-time-fhe/"><meta property="og:url" content="/writings/constant-time-client-side-fhe-operations/constant-time-fhe/"><meta property="og:updated_time" content="2025-06-20T00:00:00Z"><link rel=sitemap type=application/xml title=Sitemap href=/sitemap.xml><meta name=robots content="index,follow"><meta name=googlebot content="index,follow"><meta property="fb:admins" content><meta name=apple-mobile-web-app-title content="Adrien's Dashbook"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black"><meta name=generator content="Hugo 0.111.3"><link type=text/css rel=stylesheet href=/css/bundle.min.32e072375594147fab0331542e2b1a94787a0462b7949f9fa2a3eb72bc12113a.css><style>body{--sidebar-bg-color:#1b1838;--sidebar-img-border-color:#FFF;--sidebar-p-color:#C0C0C0;--sidebar-h1-color:#FFF;--sidebar-a-color:#FFF;--sidebar-socials-color:#FFF;--text-color:#222;--bkg-color:#FAF9F6;--post-title-color:#303030;--list-color:#2b3563;--link-color:#5e0ea5;--date-color:#515151;--table-border-color:#E5E5E5;--table-stripe-color:#F9F9F9;--code-color:#000;--code-background-color:#FAF9F6;--code-block-color:#FFF;--code-block-background-color:#1b1838;--moon-sun-color:#FFF;--moon-sun-background-color:#1b1838}body.dark-theme{--text-color:#EEE;--bkg-color:#14102a;--post-title-color:#DBE2E9;--list-color:#7e7c7c;--link-color:#05fe68;--date-color:#AAAAAA;--table-border-color:#C0C0C0;--table-stripe-color:#05fe68;--code-color:#FFF;--code-background-color:#14102a;--code-block-color:#FFF;--code-block-background-color:#14102a}body{background-color:var(--bkg-color)}</style></head><body class=dark-theme><div class=wrapper><aside class=sidebar><div class="container sidebar-sticky"><div class=light-dark align=right><button class=btn-light-dark title="Toggle light/dark mode"><svg class="moon" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/></svg><svg class="sun" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></svg></button></div><div class=sidebar-about><h1 class=brand><a href=/><img src=/images/adrienacco2.jpg alt="brand image"></a>
<a href=/><h1>Adrien's Dashbook</h1></a></h1><p class=lead>My personnal blog where I share interesting stuff</p></div><nav><ul class=sidebar-nav><li class=heading><a href=/about/>About</a></li><li class=heading><a href=/writings/>Writings</a></li><li class=heading><a href=/posts/>Posts</a></li><li class=sub-heading></li><li class=bullet><a href=/posts/first-post/>Bienvenue on my website</a></li></ul></nav><a target=_blank class=social title=GitHub href=https://github.com/abouquet27><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="-2 -2 24 24"><path fill="currentcolor" d="M18.88 1.099C18.147.366 17.265.0 16.233.0H3.746C2.714.0 1.832.366 1.099 1.099.366 1.832.0 2.714.0 3.746v12.487c0 1.032.366 1.914 1.099 2.647.733.733 1.615 1.099 2.647 1.099H6.66c.19.0.333-.007.429-.02a.504.504.0 00.286-.169c.095-.1.143-.245.143-.435l-.007-.885c-.004-.564-.006-1.01-.006-1.34l-.3.052c-.19.035-.43.05-.721.046a5.555 5.555.0 01-.904-.091 2.026 2.026.0 01-.872-.39 1.651 1.651.0 01-.572-.8l-.13-.3a3.25 3.25.0 00-.41-.663c-.186-.243-.375-.407-.566-.494l-.09-.065a.956.956.0 01-.17-.156.723.723.0 01-.117-.182c-.026-.061-.004-.111.065-.15.07-.04.195-.059.378-.059l.26.04c.173.034.388.138.643.311a2.1 2.1.0 01.631.677c.2.355.44.626.722.813.282.186.566.28.852.28.286.0.533-.022.742-.065a2.59 2.59.0 00.585-.196c.078-.58.29-1.028.637-1.34a8.907 8.907.0 01-1.333-.234 5.314 5.314.0 01-1.223-.507 3.5 3.5.0 01-1.047-.872c-.277-.347-.505-.802-.683-1.365-.177-.564-.266-1.215-.266-1.952.0-1.049.342-1.942 1.027-2.68-.32-.788-.29-1.673.091-2.652.252-.079.625-.02 1.119.175.494.195.856.362 1.086.5.23.14.414.257.553.352a9.233 9.233.0 012.497-.338c.859.0 1.691.113 2.498.338l.494-.312a6.997 6.997.0 011.197-.572c.46-.174.81-.221 1.054-.143.39.98.424 1.864.103 2.653.685.737 1.028 1.63 1.028 2.68.0.737-.089 1.39-.267 1.957-.177.568-.407 1.023-.689 1.366a3.65 3.65.0 01-1.053.865c-.42.234-.828.403-1.223.507a8.9 8.9.0 01-1.333.235c.45.39.676 1.005.676 1.846v3.11c0 .147.021.266.065.357a.36.36.0 00.208.189c.096.034.18.056.254.064.074.01.18.013.318.013h2.914c1.032.0 1.914-.366 2.647-1.099.732-.732 1.099-1.615 1.099-2.647V3.746c0-1.032-.367-1.914-1.1-2.647z"/></svg></a><a target=_blank class=social title=Gitlab href=https://gitlab.com/abouquet27><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="-2 -2.5 24 24"><path fill="currentcolor" d="M10.006 18.443 6.326 7.118h7.36l-3.68 11.325zm0 0L1.168 7.118h5.158l3.68 11.325zM1.168 7.118l8.838 11.325-9.68-7.032a.762.762.0 01-.276-.852l1.118-3.441zm0 0L3.385.296a.38.38.0 01.724.0l2.217 6.822H1.168zm8.838 11.325 3.68-11.325h5.157l-8.837 11.325zm8.837-11.325 1.119 3.441a.762.762.0 01-.277.852l-9.68 7.032 8.838-11.325zm0 0h-5.157L15.902.296a.38.38.0 01.725.0l2.216 6.822z"/></svg></a><a target=_blank class=social title=LinkedIn href=https://www.linkedin.com/in/adrien-bouquet-3a1a742a4/><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 448 512"><path fill="currentcolor" d="M416 32H31.9C14.3 32 0 46.5.0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6.0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3.0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2.0 38.5 17.3 38.5 38.5.0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6.0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2.0 79.7 44.3 79.7 101.9V416z"/></svg></a><a target=_blank class=social title=TryHackMe href=https://tryhackme.com/p/adrbqt><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="0 0 24 24"><path fill="#fff" d="M10.705.0C7.54.0 4.902 2.285 4.349 5.291a4.525 4.525.0 00-4.107 4.5 4.525 4.525.0 004.52 4.52h6.761a.625.625.0 100-1.25H4.761a3.273 3.273.0 01-3.27-3.27A3.273 3.273.0 016.59 7.08a.625.625.0 00.7-1.035 4.488 4.488.0 00-1.68-.69 5.223 5.223.0 015.096-4.104 5.221 5.221.0 015.174 4.57 4.489 4.489.0 00-.488.305.625.625.0 10.731 1.013 3.245 3.245.0 011.912-.616 3.278 3.278.0 013.203 2.61.625.625.0 001.225-.251 4.533 4.533.0 00-4.428-3.61 4.54 4.54.0 00-.958.105C16.556 2.328 13.9.0 10.705.0zm5.192 10.64a.925.925.0 00-.462.108.913.913.0 00-.313.29 1.27 1.27.0 00-.175.427 2.39 2.39.0 00-.054.514c0 .181.018.353.054.517s.095.307.175.43a.899.899.0 00.313.297c.127.073.281.11.462.11.18.0.334-.037.46-.11a.897.897.0 00.309-.296c.08-.124.137-.267.173-.431.036-.164.054-.336.054-.517.0-.18-.018-.352-.054-.514a1.271 1.271.0 00-.173-.426.901.901.0 00-.309-.291.917.917.0 00-.46-.108zm6.486.0a.925.925.0 00-.462.108.913.913.0 00-.313.29 1.27 1.27.0 00-.175.427 2.39 2.39.0 00-.053.514c0 .181.017.353.053.517s.095.307.175.43a.899.899.0 00.313.297c.127.073.281.11.462.11.18.0.334-.037.46-.11a.897.897.0 00.31-.296c.078-.124.136-.267.172-.431s.054-.336.054-.517c0-.18-.018-.352-.054-.514a1.271 1.271.0 00-.173-.426.901.901.0 00-.308-.291.916.916.0 00-.461-.108zm-8.537.068-.84.618.313.43.476-.368v1.877h.603v-2.557zm6.486.0-.841.618.314.43.477-.368v1.877h.603v-2.557zm-4.435.445c.08.0.143.028.193.084.05.057.087.127.114.21.026.083.044.173.054.269a2.541 2.541.0 010 .533c-.01.097-.028.187-.054.27a.584.584.0 01-.114.21.243.243.0 01-.193.085.248.248.0 01-.195-.086.584.584.0 01-.118-.209 1.245 1.245.0 01-.056-.27 2.645 2.645.0 010-.533c.01-.096.029-.186.056-.27a.583.583.0 01.118-.209.25.25.0 01.195-.084zm6.486.0c.08.0.144.028.193.084.05.057.087.127.114.21s.044.173.054.269a2.541 2.541.0 010 .533c-.01.097-.027.187-.054.27a.584.584.0 01-.114.21.243.243.0 01-.193.085.249.249.0 01-.195-.086.581.581.0 01-.117-.209 1.245 1.245.0 01-.056-.27 2.642 2.642.0 010-.533c.01-.096.028-.186.056-.27a.58.58.0 01.117-.209.25.25.0 01.195-.084zm-2.191 3.51a.93.93.0 00-.463.109.908.908.0 00-.312.291c-.08.122-.139.263-.175.426a2.383 2.383.0 00-.054.514c0 .18.018.353.054.516.036.164.094.308.175.432a.91.91.0 00.312.296.92.92.0 00.463.11c.18.0.333-.037.46-.11a.892.892.0 00.308-.296 1.32 1.32.0 00.174-.432c.036-.163.054-.335.054-.516.0-.18-.018-.352-.054-.514a1.274 1.274.0 00-.174-.426.89.89.0 00-.309-.291.918.918.0 00-.46-.108zm-6.402.07-.841.617.314.43.476-.369v1.878h.604v-2.557zm2.125.0-.841.617.314.43.477-.369v1.878h.603v-2.557zm2.116.0-.84.617.313.43.477-.369v1.878h.603v-2.557zm2.16.443c.08.0.144.028.194.085a.605.605.0 01.114.21c.026.083.044.172.053.269a2.639 2.639.0 010 .532 1.28 1.28.0 01-.053.27.585.585.0 01-.114.21.244.244.0 01-.193.085.25.25.0 01-.196-.085.589.589.0 01-.117-.21 1.245 1.245.0 01-.056-.27 2.597 2.597.0 010-.532c.01-.097.028-.186.056-.27a.589.589.0 01.117-.209.249.249.0 01.196-.085zm-6.729 3.073a.676.676.0 00-.335.078.661.661.0 00-.227.211.91.91.0 00-.127.31c-.027.118-.04.242-.04.373s.013.256.04.375a.93.93.0 00.127.313.65.65.0 00.227.215c.092.053.204.08.335.08a.655.655.0 00.334-.08.65.65.0 00.225-.215c.057-.09.1-.194.125-.313a1.75 1.75.0 00.04-.375c0-.13-.014-.255-.04-.373a.931.931.0 00-.125-.31.658.658.0 00-.225-.21.667.667.0 00-.334-.08zm3.086.0a.675.675.0 00-.336.078.661.661.0 00-.226.211.907.907.0 00-.127.31 1.69 1.69.0 00-.04.373c0 .131.013.256.04.375a.928.928.0 00.127.313c.058.09.134.162.226.215.093.053.205.08.336.08a.655.655.0 00.334-.08.65.65.0 00.224-.215c.058-.09.1-.194.126-.313a1.752 1.752.0 000-.748.94.94.0 00-.126-.31.657.657.0 00-.224-.21.667.667.0 00-.334-.08zm5.108.0a.675.675.0 00-.336.078.661.661.0 00-.226.211.91.91.0 00-.127.31c-.027.118-.04.242-.04.373s.013.256.04.375a.931.931.0 00.127.313c.058.09.134.162.226.215.093.053.205.08.336.08.13.0.243-.027.334-.08a.65.65.0 00.224-.215c.058-.09.1-.194.126-.313a1.75 1.75.0 00.04-.375c0-.13-.014-.255-.04-.373a.943.943.0 00-.126-.31.657.657.0 00-.224-.21.668.668.0 00-.334-.08zm-6.658.05-.61.448.227.311.346-.266v1.362h.438v-1.856zm3.068.0-.61.448.227.311.346-.266v1.362h.438v-1.856zm5.108.0-.611.448.228.311.346-.266v1.362h.438v-1.856zm-9.712.322c.058.0.105.02.14.062a.421.421.0 01.083.151.96.96.0 01.04.196 1.932 1.932.0 010 .386.954.954.0 01-.04.197.421.421.0 01-.083.152.176.176.0 01-.14.061.18.18.0 01-.141-.06.427.427.0 01-.085-.153.887.887.0 01-.041-.197 1.96 1.96.0 010-.386.893.893.0 01.04-.196.42.42.0 01.086-.151.181.181.0 01.141-.062zm3.086.0c.058.0.104.02.14.062a.421.421.0 01.082.151.94.94.0 01.04.196 1.906 1.906.0 010 .386.93.93.0 01-.04.197.421.421.0 01-.082.152.176.176.0 01-.14.061.18.18.0 01-.141-.06.42.42.0 01-.086-.153.846.846.0 01-.04-.197 1.965 1.965.0 01-.011-.195c0-.057.004-.121.01-.191a.849.849.0 01.041-.196.42.42.0 01.086-.151.182.182.0 01.141-.062zm5.108.0c.058.0.104.02.14.062a.421.421.0 01.082.151.92.92.0 01.04.196 1.963 1.963.0 010 .386.943.943.0 01-.04.197.421.421.0 01-.082.152.177.177.0 01-.14.061.18.18.0 01-.142-.06.437.437.0 01-.085-.153.95.95.0 01-.04-.197 1.965 1.965.0 01-.011-.195c0-.057.004-.121.01-.191a.959.959.0 01.04-.196.47.47.0 01.086-.151.181.181.0 01.142-.062zm-1.684 1.814a.675.675.0 00-.336.079.66.66.0 00-.227.21.91.91.0 00-.127.31 1.731 1.731.0 000 .748.939.939.0 00.127.314c.059.09.134.162.227.215s.205.08.336.08a.66.66.0 00.334-.08.648.648.0 00.224-.215c.058-.09.1-.195.126-.314a1.737 1.737.0 00-.001-.747.928.928.0 00-.125-.31.65.65.0 00-.224-.211.668.668.0 00-.334-.079zm3.063.0a.676.676.0 00-.336.079.664.664.0 00-.227.21.906.906.0 00-.127.31 1.74 1.74.0 000 .748.936.936.0 00.127.314.66.66.0 00.227.215c.092.053.204.08.336.08a.654.654.0 00.334-.08.648.648.0 00.223-.215c.058-.09.1-.195.126-.314a1.74 1.74.0 000-.747.928.928.0 00-.126-.31.65.65.0 00-.223-.211.666.666.0 00-.334-.079zm-1.545.05-.611.448.228.312.346-.267v1.363h.438v-1.856zm-1.518.323c.057.0.104.02.14.061a.42.42.0 01.082.152.91.91.0 01.04.195 1.966 1.966.0 010 .387.951.951.0 01-.04.197.421.421.0 01-.082.152.177.177.0 01-.14.06.18.18.0 01-.142-.06.428.428.0 01-.085-.152.914.914.0 01-.04-.197 1.96 1.96.0 01-.011-.195c0-.058.003-.122.01-.192a.923.923.0 01.041-.195c.02-.06.048-.11.085-.152a.181.181.0 01.142-.061zm3.063.0c.057.0.104.02.14.061a.42.42.0 01.082.152.94.94.0 01.04.195 1.91 1.91.0 010 .387.93.93.0 01-.04.197.422.422.0 01-.083.152.175.175.0 01-.14.06.18.18.0 01-.141-.06.423.423.0 01-.085-.152.907.907.0 01-.04-.197 1.95 1.95.0 010-.387.915.915.0 01.04-.195c.02-.06.048-.11.085-.152a.182.182.0 01.142-.061zm-9.713.185a.465.465.0 00-.232.055.456.456.0 00-.157.146.627.627.0 00-.089.215 1.168 1.168.0 00-.027.259c0 .09.009.177.027.26a.648.648.0 00.089.216c.04.063.093.112.157.149a.459.459.0 00.232.056c.09.0.168-.02.231-.056a.45.45.0 00.156-.149.67.67.0 00.087-.217 1.218 1.218.0 000-.518.647.647.0 00-.087-.215.448.448.0 00-.156-.146.458.458.0 00-.23-.055zm1.052.035-.423.31.158.217.24-.185v.944h.303v-1.286zm-1.052.224c.04.0.073.014.097.042a.284.284.0 01.057.105.69.69.0 01.028.136c.004.049.007.092.007.133.0.04-.003.086-.007.135a.684.684.0 01-.028.136.285.285.0 01-.057.105.123.123.0 01-.097.043.125.125.0 01-.098-.043.298.298.0 01-.059-.105.612.612.0 01-.028-.136 1.39 1.39.0 010-.268.62.62.0 01.028-.136.297.297.0 01.06-.105.125.125.0 01.097-.042zm3.775 1.394a.463.463.0 00-.232.054.452.452.0 00-.157.146.621.621.0 00-.088.214 1.19 1.19.0 000 .519.641.641.0 00.088.217.46.46.0 00.157.15.458.458.0 00.232.054.454.454.0 00.232-.055.45.45.0 00.155-.149.664.664.0 00.087-.217 1.189 1.189.0 000-.519.642.642.0 00-.087-.214.446.446.0 00-.155-.146.459.459.0 00-.232-.054zm1.052.034-.423.31.158.216.24-.185v.945h.303V22.68zm-1.052.223c.04.0.073.014.098.043a.3.3.0 01.057.105.643.643.0 01.027.135 1.31 1.31.0 010 .268.654.654.0 01-.027.137.307.307.0 01-.057.105.124.124.0 01-.098.042.125.125.0 01-.098-.042.293.293.0 01-.059-.105.618.618.0 01-.028-.137 1.364 1.364.0 010-.268.612.612.0 01.028-.135.287.287.0 01.06-.105.123.123.0 01.097-.043z"/></svg></a><a target=_blank class=social title=Telegram href=https://t.me/adrbqt><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="0 0 24 24"><path fill="currentcolor" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm4.64 6.8c-.15 1.58-.8 5.42-1.13 7.19-.14.75-.42 1-.68 1.03-.58.05-1.02-.38-1.58-.75-.88-.58-1.38-.94-2.23-1.5-.99-.65-.35-1.01.22-1.59.15-.15 2.71-2.48 2.76-2.69a.2.2.0 00-.05-.18c-.06-.05-.14-.03-.21-.02-.09.02-1.49.95-4.22 2.79-.4.27-.76.41-1.08.4-.36-.01-1.04-.2-1.55-.37-.63-.2-1.12-.31-1.08-.66.02-.18.27-.36.74-.55 2.92-1.27 4.86-2.11 5.83-2.51 2.78-1.16 3.35-1.36 3.73-1.36.08.0.27.02.39.12.1.08.13.19.14.27-.01.06.01.24.0.38z"/></svg></a><a target=_blank class=social title=Email href=mailto:adrien.bouquet@bluewin.ch><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 485.211 485.211"><path fill="currentcolor" d="M301.393 241.631 464.866 424.56H20.332l163.474-182.928 58.801 51.443 58.786-51.444zM462.174 60.651H23.027l219.579 192.142L462.174 60.651zM324.225 221.67l160.986 180.151V80.792L324.225 221.67zM0 80.792v321.029L160.972 221.64.0 80.792z"/></svg></a><p class=footnote>&copy; 2025 Adrien's Dashbook. All rights reserved.
Powered by <a target=_blank href=https://gohugo.io>Hugo</a> & <a target=_blank href=https://github.com/lukeorth/poison>poison</a></p></div></aside><main class="content container"><div class=post><div class=info><h1 class=post-title><a href=/writings/constant-time-client-side-fhe-operations/constant-time-fhe/>Constant-Time client-side FHE operations</a></h1><div><h3 class=post-description>Master semester project @ SPRING Lab, EPFL</h3></div><div class=headline><div><span>Adrien Bouquet -</span>
<time datetime=" 2025-06-20T00:00:00Z" class=post-date>June 20, 2025</time>
<span>-</span>
<span class=reading-time><span>24 mins read</span></span></div><ul class=tags><li class="tag-Constant-time FHE"><a href=/%20tags/constant-time-fhe>Constant-time FHE</a></li><li class=tag-Jasmin><a href=/%20tags/jasmin>Jasmin</a></li><li class=tag-PQC><a href=/%20tags/pqc>PQC</a></li></ul></div></div><p><em>This paper was written under the supervision of Ph. D. candidates Christian Knabenhans from SPRING Lab at EPFL and is available in PDF format <a href=/docs/constant-time-FHE.pdf>here</a></em>.</p><html xmlns=http://www.w3.org/1999/xhtml lang xml:lang><meta charset=utf-8><meta name=generator content="pandoc"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes"><meta name=author content="Adrien Bouquet"><script defer src=https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js></script>
<script>document.addEventListener("DOMContentLoaded",function(){for(var n,t=document.getElementsByClassName("math"),s=[],e=0;e<t.length;e++)n=t[e].firstChild,t[e].tagName=="SPAN"&&katex.render(n.data,t[e],{displayMode:t[e].classList.contains("display"),throwOnError:!1,macros:s,fleqn:!1})})</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css><style>div.csl-bib-body{}div.csl-entry{clear:both;margin-bottom:0}.hanging-indent div.csl-entry{margin-left:2em;text-indent:-2em}div.csl-left-margin{min-width:2em;float:left}div.csl-right-inline{margin-left:2em;padding-left:1em}div.csl-indent{margin-left:2em}</style><body><h2 id=introduction>Introduction</h2><p>The development of quantum computers presents a significant threat to
classical Public-Key cryptographic systems. Many widely deployed
cryptographic primitives, such as RSA, Diffie-Hellman, and Elliptic
Curve Cryptography (ECC)—rely on the hardness of integer factorization
or the discrete logarithm problem. These problems are vulnerable to
quantum computers, and therefore enhance research on post-quantum
cryptographic scheme.</p><p>Plenty of PQC schemes typically rely on lattice-based cryptography
because its strong security proofs, efficient implementations, and its
ranges of applications such as public-key cryptography, digital
signatures, and homomorphic encryption. Fully Homomorphic Encryption
(FHE) is a powerful cryptographic primitive that allows arbitrary
computation on encrypted data without needing to decrypt it. FHE schemes
have based their hardness assumptions on NP-Hard Lattice problem, like
Learning With Errors (LWE) and its ring variant (Ring-LWE), both of
which are believed to be quantum-resistant.</p><p>A FHE scheme is an encryption algorithm based on the property of
performing operations on encrypted data while ensuring the result’s
correctness once decrypted. Such a property allows one (or more) party
to encrypt its data and outsources it to an untrusted party (for
instance, a cloud server), which will compute the correct result and
returns to the sender, without this computing party learning the value
of the encrypted data, thus preserving the privacy of the original
party.</p><p>To achieve this property, this cryptographic primitive leverages a
homomorphism between the plaintext domain and the ciphertext domain and
respects the following properties: <span class="math display">Enc(a +
b) = Enc(a) + Enc(b)</span> <span class="math display">Enc(a \times b)
= Enc(a) \times Enc(b)</span></p><p>FHE is deployed in system requiring privacy-preserving computation,
secure data outsourcing, and applications such as encrypted machine
learning, secure voting, and private search. Therefore, there is a
strong important interest in ensure that fully homomorphic encryption
schemes are secure, cryptographically as well as in their
implementations.</p><p>In the next section, we will discuss the theoretical background to
understand the BGV scheme, an FHE scheme, and present the scheme in
itself. Then, we briefly discuss side-channel attacks and the
constant-time implementation of BGV as well as the tools used to make
this implementation.</p><h2 id=preliminaries>Preliminaries</h2><h3 id=regev-encryption-scheme>Regev encryption scheme</h3><p>In <span class=citation data-cites=LWEandRegevEncryptionScheme><a href=#ref-LWEandRegevEncryptionScheme role=doc-biblioref>[1]</a></span>, Regev introduced the
<strong>learning with error (LWE)</strong>, a lattice problem, as well
as the cryptographic system resulting from this new problem. The goal is
to hide information by using a secret vector and adding noise so that it
becomes hard to guess without the secret. The problem is defined as
follows:</p><p><strong>LWE Definition</strong> Let <span class="math inline">\mathbf{s} \in \mathbb{Z}_{q}^n</span> a secret
vector, <span class="math inline">\mathbf{a} \in \mathbb{Z}_{q}^n</span>
a vector chosen uniformly at random, <span class="math inline">e \gets
\chi</span> an noise sampled from an error distribution <span class="math inline">\chi</span> (often a discrete
Gaussian), and we
output the pair <span class="math inline">(\mathbf{a}, b = \langle
\mathbf {a}, \mathbf{s} \rangle + e \; \text{mod $q$})</span>. Given
many polynomially pair samples <span class="math inline">(\mathbf{a}_i,
b_i)</span>, find the fixed secret vector <span class="math inline">\mathbf{s}</span></p><p>Without the error term <span class="math inline">e</span>, it would
be simple to solve the equation system. However, Regev showed that
adding <span class="math inline">e</span> makes LWE at least as hard to
solve as several worst-case lattice problems, such as GapSVP or SIVP.
<span class=citation data-cites=cryptoeprint:2015/939><a href=#ref-cryptoeprint:2015/939 role=doc-biblioref>[2]</a></span>.
From this quantum hardness, Regev establishes a new public-key
cryptosystem:</p><ul><li><strong>The private key</strong> is the secret vector <span class="math inline">\mathbf{s} \in
\mathbb{Z}_{q}^n</span>.</li><li><strong>The public key</strong> is a list of <span class="math inline">m</span> pairs <span class="math inline">(\mathbf{a_i}, b_i)</span> where <span class="math inline">b_i = \langle \mathbf{a_i},
\mathbf{s} \rangle + e
\; \text{mod $q$}</span>, <span class="math inline">a_i \in
\mathbb{Z}_{q}^n</span> and <span class="math inline">e_i \gets
\chi</span>.</li><li><strong>To encrypt</strong> a bit <span class="math inline">x</span>, we choose a random subset <span class="math inline">\mathit{S}</span> of the <span class="math inline">m</span> pairs. Then, the encryption of
this bit is
<span class="math inline">(\sum_{i \in \mathit{S}}\mathbf{a_i}, \sum_{i
\in \mathit{S}}b_i + \lfloor \frac{q}{2} \rfloor x)</span></li><li><strong>To decrypt</strong> this pair <span class="math inline">(\mathbf{a}, b)</span>, we return <span class="math inline">0</span> if <span class="math inline">b- \langle
\mathbf {a}, \mathbf{s} \rangle</span> is closer to <span class="math inline">0</span> more than <span class="math inline">\lfloor
\frac{q}{2} \rfloor</span> modulo <span class="math inline">q</span>, or
<span class="math inline">1</span> otherwise.</li></ul><p>In 2010 <span class=citation data-cites=RLWE><a href=#ref-RLWE role=doc-biblioref>[3]</a></span>,
Lyubashevsky, Peikert and Regev
introduced an algebraic variant <em>Ring</em>-LWE, the
<em>ring</em>-based learning with error problem. From the original paper
<span class=citation data-cites=RLWE><a href=#ref-RLWE role=doc-biblioref>[3]</a></span>, this new RLWE
problem has the same
security strength as LWE, while being more efficient. For instance, the
polynomial multiplication can be computed efficiently by using the
Fast-Fourier Transforms (or variants such as the Number Theoretical
Transform) with highly optimized implementations.</p><p><strong>LWE</strong> had an important impact on post-quantum
cryptography. Many variants of this problem have been introduced and
demonstrated, whereas several cryptographic algorithms have been based
on this problem (or its variants). For instance, some Public-Key
Cryptosystems, such as CRYSTALS-KYBER <span class=citation data-cites=kyber><a href=#ref-kyber role=doc-biblioref>[4]</a></span>, FHE schemes, as BFV or BGV<span class=citation data-cites=BGV><a href=#ref-BGV role=doc-biblioref>[5]</a></span>, or Digital Signature schemes, as
CRYSTALS-Dilithium, are based on variants of LWE.</p><p>Regarding the scope of this paper, we will be focusing primarly on
BGV scheme<span class=citation data-cites=BGV><a href=#ref-BGV role=doc-biblioref>[5]</a></span>.</p><h3 id=bgv-encryption-scheme>BGV encryption scheme</h3><p>Introduced in <span class=citation data-cites=BGV><a href=#ref-BGV role=doc-biblioref>[5]</a></span> by
Brakerski, Gentry
and Vaikuntanathan, BGV is a Fully Homomorphic encryption scheme based
on the R-LWE problem, and is very close to BFV <span class=citation data-cites=BFV><a href=#ref-BFV role=doc-biblioref>[6]</a></span>
another lattices-based FHE scheme. Compared to BFV, BGV has multiple
ciphertext modulis <span class="math inline">p_i</span> depending on its
parameter <span class="math inline">L</span> (described thereafter).
Both algorithms also differ in their message scaling, which prevents the
noise from growing to much after executing many operations.</p><h4 data-number=2.2.1 id=parameters-polynomial-rings-and-distributions><span class=header-section-number></span> Parameters, Polynomial Rings
and Distributions</h4><p>Regarding BGV’s parameters, we define <span class="math inline">L</span> as the number of prime modulis <span class="math inline">p_i</span>, <span class="math inline">q_l = p_0
\times ... \times p_{l}</span> is the ciphertext modulus corresponding
to the encryption level <span class="math inline">l</span>, where <span class="math inline">0 \leq l \leq L</span>,
<span class="math inline">n</span> as the degree of the polynomials<a href=#fn1 class=footnote-ref id=fnref1 role=doc-noteref><sup>1</sup></a>, and <span class="math inline">t</span> the plaintext modulus<a href=#fn2 class=footnote-ref id=fnref2 role=doc-noteref><sup>2</sup></a>.
From these parameters, the plaintext polynomial ring is defined as <span class="math inline">\mathcal{P} =
\mathcal{R}_{t} = \mathbb{Z}_{t}[x] /
(x^n + 1)</span> where all coefficients are in <span class="math inline">\mathbb{Z}_{t}</span>, the ciphertext
ring as <span class="math inline">\mathcal{C} = \mathcal{R}_{q_l} \times
\mathcal{R}_{q_l}</span> a pair of polynomials in <span class="math inline">\mathcal{R}_{q_l} =
\mathbb{Z}_{q_l}[x] / (x^n +
1)</span>, whose coefficients are in <span class="math inline">\mathbb{Z}_{q}</span>.</p><p>Finally, the protocol relies on three different distributions to
sample random polynomials:</p><ul><li>A Uniform ternary distribution over <span class="math inline">\mathcal{R}_{2} = \{-1, 0, 1\}</span><a href=#fn3 class=footnote-ref id=fnref3 role=doc-noteref><sup>3</sup></a>
mainly for the secret key.</li><li>A Uniform distribution over <span class="math inline">\mathcal{R}_{q}</span></li><li>A (truncated) Discrete Gaussian distribution <span class="math inline">\chi</span> for error polynomials, with
parameters
<span class="math inline">\mu = 0</span>, <span class="math inline">\sigma = 3.2</span> and <span class="math inline">\beta = 19</span> according to <span class=citation data-cites="HomomorphicEncryptionSecurityStandard inferati_fhe_bgv"><a href=#ref-HomomorphicEncryptionSecurityStandard role=doc-biblioref>[7]</a>, <a href=#ref-inferati_fhe_bgv role=doc-biblioref>[8]</a></span>. <span class="math inline">\beta</span>
corresponds to the absolute bound of
the truncated discrete gaussian i.e., each element <span class="math inline">x</span> is in <span class="math inline">\{-19, ...,
0, ..., 19\}</span></li></ul><h4 data-number=2.2.2 id=protocol-clients-primitive><span class=header-section-number></span> Protocol
Client’s
primitive</h4><p>In the scope of this project, we only considered the client’s
primitive, i.e. the Key Generation, the Encryption and the Decryption.
In fact, we consider that the usage of this BGV client implementation is
for instance to encrypt and decrypt data stored on the cloud, without
applying any intermediate server operation, while offering constant-time
computation. These three primitives are similar from Regev’s encryption
scheme.</p><p><strong>The Key Generation</strong> takes the client’s secret key
<span class="math inline">\mathsf{SK}</span>, a random ternary
polynomial over <span class="math inline">\mathcal{R}_{2}</span>, as
input and computes the public key <span class="math inline">\mathsf{PK}
= (\mathsf{PK_1}, \mathsf{PK_2})</span> as follows:</p><p><span class="math display">\mathsf{PK_1}= -1(a \cdot \mathsf{PK} + t
\cdot e) \; \text{mod $q_l$}</span> <span class="math display">\mathsf{PK_2} = a</span></p><p>where <span class="math inline">a</span> is a polynomial sampled
uniformly at random over <span class="math inline">\mathcal{R}_{q_l}</span>, and <span class="math inline">e</span>
is a random error polynomial sampled over
<span class="math inline">\chi</span>. Here, <span class="math inline">t</span> is the scaling factor.</p><p><strong>The Encryption</strong> takes a plaintext <span class="math inline">\mathsf{M} \in \mathcal{P}</span>, and
the
previously computed public key <span class="math inline">\mathsf{PK}</span>, and outputs the ciphertext <span class="math inline">\mathsf{C} = (\mathsf{C_1}, \mathsf{C_2}) \in
\mathcal{C}</span> as follows:</p><p><span class="math display">\mathsf{C_1} = (\mathsf{PK_1} \cdot u + t
\cdot e_1 + \mathsf{M} ) \; \text{mod $q_l$}</span> <span class="math display">\mathsf{C_2} = (\mathsf{PK_2}
\cdot u + t \cdot
e_2) \; \text{mod $q_l$}</span></p><p>where <span class="math inline">u</span> is a ternary polynomial
sampled uniformly at random over <span class="math inline">\mathcal{R}_{2}</span>, and <span class="math inline">e_1</span> and <span class="math inline">e_2</span>
are random error polynomials sampled over <span class="math inline">\chi</span>.</p><p><strong>The Decryption</strong> returns the original message <span class="math inline">M</span> by taking the
corresponding ciphertext
<span class="math inline">\mathsf{C} = (\mathsf{C_1},
\mathsf{C_2})</span> and the client’s secret key <span class="math inline">\mathsf{SK}</span> in the following
way:<a href=#fn4 class=footnote-ref id=fnref4 role=doc-noteref><sup>4</sup></a></p><p><span class="math display">\mathsf{C_1} + \mathsf{C_2} \cdot
\mathsf{SK} \; \text{mod $t$} = \mathsf{M} + t \cdot v \; \text{mod
$t$} = M \; \text{mod $t$}</span></p><p>where <span class="math inline">v</span> is the noise vector.
However, the last equality is correct only if <span class="math inline">\|v\|_\infty &lt; \frac{q_l}{2t}</span>, due
to
noise growth being to important, thus destroying the message.</p><p>Consequently, the security property is based on the hardness for an
adversary to recover the plaintext from the ciphertext plus some noise,
without knowing the secret key, similarly to LWE.</p><p><strong>Remark on <span class="math inline">\mathcal{R}_{q_l}</span></strong> Previously, we
defined all the polynomial’s coefficients in <span class="math inline">\mathcal{R}_{q_l}</span>. In practice, we do
not
multiply each small modulis <span class="math inline">p_i</span> but
rather perform all operation for each modulus individually and send
<span class="math inline">l</span> polynomials. Hence we have an
efficient solution, while preserving its correctness. In fact, as the
smaller modulis are all primes, and a fortiori pairwise coprime, we can
apply the Chinese Remainder Theorem to show that the mapping</p><p><span class="math display">\mathcal{R}_{q_l} \cong \mathcal{R}_{p_0}
\times ... \times \mathcal{R}_{p_l}</span></p><p>is a ring isomorphism.</p><h3 id=side-channel-attacks>Side-channel attacks</h3><p>Although lattices-based cryptography and FHE offer strong
cryptographic properties, it is still possible for an adversary to
recover the encrypted data. Side-channel attacks can be deployed and
targets implementations to leverage physical leakage and exploiting
vulnerabilities.</p><p>Homomorphic Encryption algorithms can have multiples attack vectors.
Single power measurement analysis on BFV Gaussian sampler based on
control-flow variations <span class=citation data-cites=attackondgs><a href=#ref-attackondgs role=doc-biblioref>[9]</a></span>, cache-timing attack triggered by a
non-constant time Barrett modular multiplication <span class=citation data-cites=cachetiminattack><a href=#ref-cachetiminattack role=doc-biblioref>[10]</a></span>, or two single measurement attacks
due to ternary value assignment leaking during the Key Generation phase
<span class=citation data-cites=attackonkeygen><a href=#ref-attackonkeygen role=doc-biblioref>[11]</a></span> are
examples of feasible side-channel attacks on FHE implementations to
obtain the secret key with high precision. Therefore, constant-time and
formally verified implementations are necessary to ensure the systems’
security.</p><p><strong>Remark on constant-timeness.</strong> When referring to
constant-timeness for an implementation or a program, we only consider
the constant-timeness of the code, not the hardware. According to
definition from Jasmin repository’s wiki <span class=citation data-cites=jasminwiki><a href=#ref-jasminwiki role=doc-biblioref>[12]</a></span>, “a program is said to be constant
time when neither the control-flow nor the memory accesses depend on
sensitive data”. Hence, we assume that hardware operations are
correct.</p><h3 id=projects-description>Project’s description</h3><p>In this project, we implement a BGV scheme in Jasmin, a safe
high-assurance and high-speed cryptographic language. We deploy
well-known cryptographic efficient or constant-time techniques (Barrett
Reduction, NTT, …), and we used a Rust wrapper to handle and test the
Jasmin implementations. Ensuring and proving constant-timeness and
rigorous reasoning require to trust considerably and increase the attack
surface.</p><h2 id=technical-section>Technical Section</h2><p>In this section, we detail the Jasmin implementation of our BGV
client i.e., the difference with ML-KEM, our set-up and the
implementation of the different primitives we used, as well as the Rust
wrapper that will call the assembly extracted from Jasmin to run and
test its functionality. Our implementation is based the on MLKEM Jasmin
implementation from <span class=citation data-cites=jasminkyber><a href=#ref-jasminkyber role=doc-biblioref>[13]</a></span>, and
therefore will adopt much of their nomenclature and approach, although
with some significant differences.</p><h3 id=from-kyber-implementation-to-bgv>From KYBER implementation to BGV</h3><p>Compared to their ML-KEM implementation, BGV requires less
cryptographic primitives (KDF, Hash function, …), whereas it needs to be
more modular than KYBER. In fact, parameters, such as the modulo <span class="math inline">q</span> or the
polynomial size <span class="math inline">n</span>, are generally fixed in ML-KEM. For
instance, <span class="math inline">q</span> is often 3329 like for
KYBER-512 or KYBER-1024 (c.f. <span class=citation data-cites=Avanzi2017CRYSTALSKyberAS><a href=#ref-Avanzi2017CRYSTALSKyberAS role=doc-biblioref>[14]</a></span>). For BGV, there are small multiple
modulis <span class="math inline">\{p_0,p_1,...,p_L \}</span>, all of
which can be modified according to the bit size of the Encryption Level
modulo <span class="math inline">q_L = p_0 \times ... \times
p_{L}</span>.</p><p>Another difference is the wrapper and testing environment around the
Jasmin code. In the original implementation, the Jasmin code is compiled
in assembler by the Jasmin compiler, and called at runtime by a C
wrapper. For this project, we made the wrapper in Rust to extend the
deployment assembly compiled from Jasmin to another language.</p><p>On the other hand, plenty of primitives used by the BGV scheme are
very similar and already done for KYBER implementation, such as the NTT
and INTT, Barrett and Montgomery reduction. Therefore, they needed to be
partially adapted to match our implementation. Furthermore, we keep
functions and files nomenclature from the original project. In fact,
functions having the <code>export</code>keyword are meant to be
accessible by outside and serves as API for the Jasmin code. Therefore,
will be written with a ‘j’ as the first letter (e.g.,
<code>jbgv_encrypt_jazz</code>); function starting with a <code>_</code>
(e.g., <code>_poly_reduce_mod_t</code>) are functions that performs
operation directly on polynomials; and finally the other functions are
performing operations on values (e.g.,
<code>__barrett_reduce_Q1</code>). Similarly, if a file contains
functions that can be called from outside, its name will begin with a
‘j’ and end with <code>.jazz</code>, while others will only end in
<code>.jinc</code>.</p><h3 id=set-up>Set up</h3><p>For our project, we aim to make the project work for the parameters
<span class="math inline">n = 1024 = 2^{10}</span>, and <span class="math inline">log_2(q) = 52</span>, according to
the Homomorphic
Encryption Security Standard<span class=citation data-cites=HomomorphicEncryptionSecurityStandard><a href=#ref-HomomorphicEncryptionSecurityStandard role=doc-biblioref>[7]</a></span>. However, computing and
compiling
constants such as the <span class="math inline">\Psi</span> tables for
<span class="math inline">n = 1024</span> coefficients was too costly
for Jasmin compiler. Hence, our default version start at <span class="math inline">n = 32</span>. In addition, we
stay with only one
modulus (i.e., <span class="math inline">L = 1</span>). As all the
constants will be replaced directly in the code assembly by the Jasmin
compiler, we have implemented the whole protocol for a modulus q1, and
afterwards we could develop the Rust wrapper builder so that it
duplicates the Jasmin implementations according to the number of modulis
chosen, calculates all the variables depending on each modulus (e.g.,
the <span class="math inline">\psi</span> needed for the NTT), and
writes them directly to each respective Jasmin project before compiling
and using them. We also fixed the plaintext modulus <span class="math inline">t</span> to <span class="math inline">65537</span>,
as described in <span class=citation data-cites=cryptoeprint:2021/204><a href=#ref-cryptoeprint:2021/204 role=doc-biblioref>[15]</a></span>. In fact, <span class="math inline">t</span> must be of the form <span class="math inline">p^r</span>, where <span class="math inline">p</span>
is coprime to <span class="math inline">2n</span>. Hence, we fixed <span class="math inline">r = 1</span> and <span class="math inline">p =
2^{16} + 1</span>.</p><p>In addition, the coefficients are computed on 64-bits unsigned
integers. It is necessary to emphasize that the integer representation
in <span class="math inline">\mathbb{Z}_q</span> and in <span class="math inline">\{0,...,2^{64}-1\}</span> is
obviously not the same.
Therefore, subtractions and all other overflow/underflow problems must
be handled cautiously to maintain the system coherency. Therefore, the
Montgomery factor used for its form will be <span class="math inline">2^{64}</span>.</p><p>Finally, we assume that all the basic operations (addition,
multiplication) supported and compiled by the Jasmin compiler are made
in constant-time since Jasmin’s thread model assume that its generated
assembly executed on hardware with constant-time operations as described
previously. We also assume that all vectors are in Montgomery form and
NTT form upon performing multiplications, additions, or any other
operations.</p><h3 id=basic-polynomial-operations>Basic polynomial operations</h3><p>Mostly taken from the original implementation, we only have
polynomial addition and element-wise multiplication as two basic
operations on polynomial. Basically, these two functions performs their
operations in <span class="math inline">\mathbb{Z}_q</span>.</p><h3 id=barrett-reduction>Barrett Reduction</h3><p>When computing values in <span class="math inline">\mathbb{Z}_q</span>, we need the modulo
<code>%</code> operation. Even if Jasmin supports the modulo, it’s
clearly not most efficient and practical operation as it might take a
lot of time to compute the result. Hence, we implemented the Barrett
reduction algorithm, which reduces an element to its remainder in a
field. Although a version exists for ML-KEM, ours is taken from the
OpenFHE’s project<span class=citation data-cites=OpenFHE><a href=#ref-OpenFHE role=doc-biblioref>[16]</a></span>, which adapts
the algorithm described in <span class=citation data-cites=menezes1996handbook><a href=#ref-menezes1996handbook role=doc-biblioref>[17]</a></span>. We implemented it to reduce a
128-bit unsigned integer split in two 64-bits integer modulo the
ciphertext modulus <span class="math inline">q</span>, as well as to
reduce a 64-bit modulo <span class="math inline">t</span> our plaintext
modulus.</p><h3 id=montgomery-reduction>Montgomery Reduction</h3><p>Another well known primitive used for its efficiency is the
Montgomery reduction <span class=citation data-cites=montgomery_reduction><a href=#ref-montgomery_reduction role=doc-biblioref>[18]</a></span>. This algorithm allows to speed
modular multiplication without modifying the addition. In fact, every
coefficient in <span class="math inline">\mathbb{Z}_{q}</span> will be
represented as <span class="math inline">\bar{a} = aR \text{mod}
q</span>, where <span class="math inline">a</span> is the coefficient in
normal form, and <span class="math inline">R</span> is a radix such that
<span class="math inline">R\ge q</span> and <span class="math inline">\text{gcd}(q,R) = 1</span>. We call <span class="math inline">\bar{a}</span>, the Montgomery form of <span class="math inline">a</span>. Therefore, addition
and multiplication
with Montgomery form become: <span class="math display">aR + bR = (a +
b)R \quad \text{mod $q$}</span> <span class="math display">(a \times b)
R = (aR \times bR)R^{-1} = (\bar{a} \times \bar{b})R^{-1} \quad
\text{mod $q$}</span></p><p>We use Montgomery reduction to speed up algorithm by “allowing
efficient implementations of modular multiplication without explicitly
carrying out the classical modular reduction step”. <span class=citation data-cites=menezes1996handbook><a href=#ref-menezes1996handbook role=doc-biblioref>[17]</a></span>
Chapter 14. As the modulus <span class="math inline">q</span> will be
always odd, we can fix the radix <span class="math inline">R</span> to
be a power of 2. Hence, we choose <span class="math inline">R =
2^{64}</span>.</p><p>In <code>bgvpoly.jinc</code>, we created the methods
<code>_poly_from_mont</code> and <code>_poly_to_mont</code>, which
transforms a polynomial’s coefficients from their Montgomery form to
their normal form, and vice-versa. Furthermore, we implemented the
method <code>__fqmul</code> in <code>bgvreduce.jinc</code>, which takes
two unsigned 64-bits integer in Montgomery form and returns their
product in <span class="math inline">\mathbb{Z}_{q}</span> according to
the multiplication described above.</p><h3 id=ntt-amp-intt>NTT & INTT</h3><p>Multiplying two polynomials in the quotient ring <span class="math inline">\mathcal{R}_{q} = \mathbb{Z}_{q}[X] /
(X^n +
1)</span> is equivalent to the convolution of the coefficients reduced
modulo <span class="math inline">q</span>, and then performing a long
division on the new polynomial of degree <span class="math inline">\leq
2n</span> by <span class="math inline">X^n + 1</span>. Computing this
convolution and this division is costly and clearly not constant-time
depending on the input polynomials. To optimize and reduce the cost of
the operations, many encryption schemes rely on the Number Theoretic
Transform <span class=citation data-cites=cryptoeprint:2024/585><a href=#ref-cryptoeprint:2024/585 role=doc-biblioref>[19]</a></span>,
or NTT, (and a fortiori, its inverse) to represent their polynomials
into vectors. Indeed, two polynomial in NTT form can be multiplied
element-wise, reduced modulo <span class="math inline">q</span>, and
after retransforming the computed into its normal form after applying
the Inverse NTT, we obtain the same results as performing the
convolution and the long division. Furthermore, the NTT also satisfies
the addition and the scalar multiplication, thus keeping the coherency
for polynomial addition and Montgomery form.</p><p>Similarly to other implementations, we base the NTT on the
Cooley-Turkey (CT) butterfly algorithm, and the INTT on Gentleman-Sande
(GS) butterfly algorithm from <span class=citation data-cites=ntt_transform><a href=#ref-ntt_transform role=doc-biblioref>[20]</a></span> (Algorithm 1 & 2). Both
algorithms are optimized variants of these two transforms. The NTT make
use of the precomputed table <span class="math inline">\Psi \in
\mathbb{Z}^n_q</span>, which stores powers of <span class="math inline">\psi</span>, a primitive 2<span class="math inline">n</span>-th root of unity in <span class="math inline">\mathbb{Z}_q</span> such that <span class="math inline">\psi^n \equiv -1 \ \text{mod} \ q</span>, while
the INTT make use of the precomputed table <span class="math inline">\Psi^{-1} \in \mathbb{Z}^n_q</span>, which
stores
powers of <span class="math inline">\psi^{-1}</span>, the multiplicative
inverse in <span class="math inline">\mathbb{Z}_q</span>. To speed up
the computation, these tables are precomputed by the Rust wrapper and
hard-coded in file <code>psis.jinc</code> before compiling the code<a href=#fn5 class=footnote-ref id=fnref5 role=doc-noteref><sup>5</sup></a>. The Rust wrapper NTT implementation
(c.f. <code>helpers/ntt.rs</code>), and <span class="math inline">\Psi</span> computation (in Montgomery form) are
adapted from the Lattirust library, maintained by Christian Knabenhans
<span class=citation data-cites=lattirust2025><a href=#ref-lattirust2025 role=doc-biblioref>[21]</a></span>.</p><h3 id=sampling-randoms-polynomial>Sampling randoms polynomial</h3><p>Sampling random polynomials according to multiple distributions is a
key primitive of lattice encryption schemes such as BGV or KYBER. The
main challenge is preserving the distribution correctness from bytes
randomly generated while sampling the coefficient in constant-time. In
our BGV implementation based on <span class=citation data-cites=inferati_fhe_bgv><a href=#ref-inferati_fhe_bgv role=doc-biblioref>[8]</a></span>, we consider the three 3 types of
distribution in previously mentioned.</p><p>All the functions that samples random polynomials according to the
three distributions mentioned above are implemented in
<code>src/jasmin/sampler.jinc</code>. In the following subsection, we
described how we handled the Jasmin Syscall generating random bytes, and
the reasoning behind each sampling implementations.</p><h4 data-number=3.7.1 id=jasmin-syscall><span class=header-section-number></span> Jasmin Syscall</h4><p>To generates random bytes in Jasmin, there exist the Syscall
<code>#randombytes</code>, which takes a <code>reg ptr</code> (i.e., a
pointer morally <span class=citation data-cites=jasminwiki><a href=#ref-jasminwiki role=doc-biblioref>[12]</a></span> Section
Arrays). However, the Syscall must be handled by the user according to
the project’s wiki. In our project, we implemented the function
<code>__jasmin_syscall_randombytes__</code> in Rust (c.f.
<code>main.rs</code>) taking a raw pointer on unsigned bytes and a
length, and returning the same pointer with each byte randomly
generated.<a href=#fn6 class=footnote-ref id=fnref6 role=doc-noteref><sup>6</sup></a> Because the Syscall’s
function body
is not considered by Jasmin in its threat model, we assume that its in
constant time. In practice, we must verify that its implementation is
constant-time.</p><h4 data-number=3.7.2 id=uniform-distribution-sampling><span class=header-section-number></span> Uniform
Distribution
Sampling</h4><p>To ensure uniform distribution sampling, we adopted two methods. For
ternary polynomials, we proceed by rejection sampling (c.f.
<code>__sample_random_poly_ternary</code>). For each coefficient, we
generate one byte, and we keep only the last two bits. If these two bits
equals 3, we redraw the byte. Otherwise, we subtract one. Hence, we
prevent the secret key from being biased because the value 0 and 3 are
congruent modulo 3, and will increase the probability of having -1 for
each coefficient of the secret key.</p><p>For polynomials over <span class="math inline">\mathcal{R}_{q}</span>
(c.f. <code>__sample_random_poly_mod_q</code>), we avoid rejection
sampling because it will be clearly inefficient. Instead, we generate
randomly <span class="math inline">n+2</span> 64-bits unsigned integer.
Then, we remove the two extras 64-bits integer, and we apply the modulo
on the <span class="math inline">n</span> integer remaining. In fact,
adding the two extra integers reduces the bias probability, and hence we
can approximate the uniform distribution as closely as possible.</p><h4 data-number=3.7.3 id=gaussian-distribution-sampling><span class=header-section-number></span> Gaussian
Distribution
Sampling</h4><p>To sample values following a discrete Gaussian distribution, we
adapted the <code>DGS_DISC_GAUSS_UNIFORM_TABLE</code> from <span class=citation data-cites=dgs><a href=#ref-dgs role=doc-biblioref>[22]</a></span>. This sampler uses a precomputed
table of probabilities <span class="math inline">\rho</span>, where the
number of entries corresponds to the size of the set covered by of the
Gaussian distribution (i.e. <span class="math inline">2*\beta +
1</span>). In our situation, there are <span class="math inline">39</span> entries from <span class="math inline">0</span> to <span class="math inline">38</span><a href=#fn7 class=footnote-ref id=fnref7 role=doc-noteref><sup>7</sup></a>. Each entry’s probability is
computed as follows:</p><p><span class="math display">\rho_x = \exp^{-\frac{(x -
\mu)^2}{2\sigma^2}} \quad {-\beta} \leq x \leq \beta</span></p><p>As they are probabilities, each <span class="math inline">\rho_x</span> are in <span class="math inline">[0,1]</span>. However, Jasmin does not support
Floating-point value, and hence, we cannot store the table as it is. By
multiplying each value by <span class="math inline">2^{64}</span> and
rounding them, we keep the same distribution while using unsigned 64-bit
integer as comparison. Therefore, we can precompute the table with the
Rust wrapper, and we can directly write it in the Jasmin code (c.f.
<code>rhos.jinc</code>).</p><p>To generate our coefficients with respect to the Gaussian
distribution, we then proceed as follows (c.f.
<code>__sample_gaussian_distribution</code>):</p><ul><li>We generate a random byte <span class="math inline">x</span>, we
keep only the six last bit and if the value is greater than 39, we
redraw.</li><li>We generate a random 64-bits unsigned integer <span class="math inline">y</span>.</li><li>If <span class="math inline">y</span> is smaller than <span class="math inline">\rho_x</span>, we keep <span class="math inline">x</span> and subtract <span class="math inline">\beta</span> to obtain the real
corresponding
offset. The result will be our coefficient. Otherwise, we restart at the
first step.</li></ul><p>We continue this procedure until we obtain a valid coefficient, and
we repeat for each coefficient of the vector.</p><h3 id=clients-protocol>Client’s protocol</h3><p>Similarly to Inferati’s post <span class=citation data-cites=inferati_fhe_bgv><a href=#ref-inferati_fhe_bgv role=doc-biblioref>[8]</a></span> and according to the BGV’s protocol,
we split in 3 key function in the <code>jbgv.jazz</code>:</p><ul><li><code>jbgv_keygen_secret_key</code> generates the client’s secret
key according to the ternary distribution.</li><li><code>jbgv_encrypt_jazz</code> takes the client’s secret key and a
plaintext, and returns the corresponding ciphertext.</li><li><code>jbgv_decrypt_jazz</code>takes the client’s secret key, and a
ciphertext, and returns the corresponding plaintext.</li></ul><p>We choose to generate a random public key for each new plaintexts,
and we don’t store the public key, only the secret, because we don’t
need it to decrypt the ciphertext.</p><p>To compile the Jasmin code with the Jasmin compiler, go in
<code>src/jasmin/</code> and run in terminal:</p><div class=sourceCode id=cb1><pre class="sourceCode bash"><code class="sourceCode bash"><span id=cb1-1><a href=#cb1-1 aria-hidden=true tabindex=-1></a>    <span class=op>&gt;</span> jasminc <span class=ex>jbgv.jazz</span> <span class=at>-o</span> jbgv.s</span></code></pre></div><p>To run an example of the protocol, run:</p><div class=sourceCode id=cb2><pre class="sourceCode bash"><code class="sourceCode bash"><span id=cb2-1><a href=#cb2-1 aria-hidden=true tabindex=-1></a>    <span class=op>&gt;</span> cargo <span class=ex>main</span></span></code></pre></div><p>To run all the test, run:</p><div class=sourceCode id=cb3><pre class="sourceCode bash"><code class="sourceCode bash"><span id=cb3-1><a href=#cb3-1 aria-hidden=true tabindex=-1></a>    <span class=op>&gt;</span> cargo <span class=bu>test</span> <span class=at>--</span> <span class=at>--include-ignored</span></span></code></pre></div><h2 id=result>Result</h2><h3 id=methodology>Methodology</h3><p>At first, we decided to keep the wrapper in C as in the KYBER
repository, but in the end, we adopted Rust as our wrapper. To call the
assembly compiled from Jasmin from Rust, we use a <code>build.rs</code>
script, which builds the Rust project each time <code>jbgv.s</code>has
been modified, and compile such that it can be used as a library by the
Rust project.</p><p>In <code>src/helpers/</code>, there are all the Rust files
implementing either cryptographic functions ((I)NTT, Key generation,
Encryption, etc), or functions that (pre)compute constant modulus, <span class="math inline">2n</span>th-root of
unity, <span class="math inline">\rho_x</span>, … To ensure an “informal” functionnal
correctness, we implemented the wrapper and the Jasmin project in
parallel, and created a test suite in two parts:</p><ul><li>in <code>bgvpoly.rs</code>, there are all tests on function that
performing operations on polynomials (e.g., addition, ntt, sampling,
etc).</li><li>in <code>bgv.rs</code>, there are all the tests on the protocol’s
functions (Key Generation, Encryption, etc)</li></ul><p>Finally, the parameters can be found in
<code>src/helpers/config.rs</code> for Rust, and in
<code>src/jasmin/{params.jinc, psis.jinc, rhos.jinc}</code> for
Jasmin.</p><h3 id=benchmark>Benchmark</h3><p><strong>Time Benchmark.</strong> We made some benchmarks to evaluates
the efficiency of the Jasmin implementation compared to Rust. For
performing <span class="math inline">2000000</span> NTT in a row, Jasmin
has an overall mean of <span class="math inline">5.096
\mu\text{s}</span>, compared with an overall mean of <span class="math inline">11.801\mu\text{s}</span> for Rust.
Similarly with
INTT, Jasmin took <span class="math inline">5.319\mu\text{s}</span>,
compared with an overall mean of <span class="math inline">14.633\mu\text{s}</span> for Rust.</p><p><strong>Gaussian Sampler accuracy.</strong> To verify our sampler
accuracy, we sampled <span class="math inline">200000</span> polynomials
of <span class="math inline">n=32</span>, we classified them and we
computed the estimated mean and standard deviation. We obtain an
estimated mean <span class="math inline">\mu'</span> of <span class="math inline">0.0022</span>, and an
estimated standard deviation
<span class="math inline">\sigma'</span> of <span class="math inline">3.1985</span>.</p><h3 id=jasmin-takeaway>Jasmin Takeaway</h3><p>Jasmin is a very interesting language based on a lot of good
concepts. The possibility of having a very powerful cryptographic
language that allows you to export its functional implementation to a
formal verification tool, such as Easycrypt, is practical and powerful.
However, the lack of documentation or tutorials was limiting to
understand and exploit all the features and advantages of the language.
Another example is the error returned by the compiler, which sometimes
lacks clear explaination. These projects reflect the complexity of
academic research, for which documentation and the scope of development
are limited.</p><p>Nevertheless, we did not entirely reached the goal of the project, as
we were not able to formally verify the constant-timeness of our
implementation by extracting the proof from our Jasmin program and
running Easycrypt.</p><h2 id=future-work>Future Work</h2><h3 id=easycrypt-extraction-and-proving-constant-timeness>Easycrypt extraction and proving constant-timeness</h3><p>Afterwards, our intention is to use the Easycrypt framework, by
extracting our Jasmin implementation, which can be done natively by
Jasmin, to prove its cryptographic security and constant-timeness.</p><h3 id=rust-wrapper-extension>Rust Wrapper extension</h3><p>In future development, we want to develop the Rust build script to be
able to compile all the Jasmin code, as well as handling multiple
modulus by duplicates Jasmin projects for each modulus and its
respective constants, write in Jasmin and Rust file. The objective would
be to have a completely modular program with a default
configuration.</p><h2 id=conclusion>Conclusion</h2><p>This project presented a constant-time client-side implementation of
the BGV Fully Homomorphic Encryption scheme, targeting both
cryptographic soundness and implementation-level security. Built on
post-quantum lattice assumptions, FHE ensures privacy-preserving
computation, making it a compelling solution in a future shaped by
quantum threats. By leveraging the Jasmin language for secure and
verifiable low-level programming, we demonstrated the feasibility of
implementing BGV primitives in a constant-time manner, while also
addressing challenges such as polynomial arithmetic, modular reduction,
and secure sampling.</p><p>Although full formal verification via EasyCrypt remains future work,
our results highlight the practicality and performance benefits of
carefully engineered constant-time implementations. As the need for
secure data processing continues to grow—particularly in areas like
cloud computing and machine learning—FHE, and efficient, secure
implementations like the one developed in this project, will be key to
building strong, quantum-resistant privacy solutions.</p><h2 id=references>References</h2><div id=refs class="references csl-bib-body" data-entry-spacing=0 role=list><div id=ref-LWEandRegevEncryptionScheme class=csl-entry role=listitem><div class=csl-left-margin>[1]</div><div class=csl-right-inline>O.
Regev, <span>“On lattices, learning with errors, random linear codes,
and cryptography,”</span> in <em>Proceedings of the thirty-seventh
annual ACM symposium on theory of computing</em>, in STOC ’05. New York,
NY, USA: Association for Computing Machinery, 2005, pp. 84–93. doi: <a href=https://doi.org/10.1145/1060590.1060603>10.1145/1060590.1060603</a>.</div></div><div id=ref-cryptoeprint:2015/939 class=csl-entry role=listitem><div class=csl-left-margin>[2]</div><div class=csl-right-inline>C.
Peikert, <span>“A decade of lattice cryptography.”</span> Cryptology
<span>ePrint</span> Archive, Paper 2015/939, 2015. Available: <a href=https://eprint.iacr.org/2015/939>https://eprint.iacr.org/2015/939</a></div></div><div id=ref-RLWE class=csl-entry role=listitem><div class=csl-left-margin>[3]</div><div class=csl-right-inline>V.
Lyubashevsky, C. Peikert, and O. Regev, <span>“On ideal lattices and
learning with errors over rings,”</span> <em>J. ACM</em>, vol. 60, no.
6, Nov. 2013, doi: <a href=https://doi.org/10.1145/2535925>10.1145/2535925</a>.</div></div><div id=ref-kyber class=csl-entry role=listitem><div class=csl-left-margin>[4]</div><div class=csl-right-inline>J.
Bos <em>et al.</em>, <span>“<span>CRYSTALS</span> – kyber: A
<span>CCA</span>-secure module-lattice-based <span>KEM</span>.”</span>
Cryptology <span>ePrint</span> Archive, Paper 2017/634, 2017. doi: <a href=https://doi.org/10.1109/EuroSP.2018.00032>10.1109/EuroSP.2018.00032</a>.</div></div><div id=ref-BGV class=csl-entry role=listitem><div class=csl-left-margin>[5]</div><div class=csl-right-inline>Z.
Brakerski, C. Gentry, and V. Vaikuntanathan, <span>“Fully homomorphic
encryption without bootstrapping.”</span> Cryptology <span>ePrint</span>
Archive, Paper 2011/277, 2011. Available: <a href=https://eprint.iacr.org/2011/277>https://eprint.iacr.org/2011/277</a></div></div><div id=ref-BFV class=csl-entry role=listitem><div class=csl-left-margin>[6]</div><div class=csl-right-inline>J.
Fan and F. Vercauteren, <span>“Somewhat practical fully homomorphic
encryption.”</span> Cryptology <span>ePrint</span> Archive, Paper
2012/144, 2012. Available: <a href=https://eprint.iacr.org/2012/144>https://eprint.iacr.org/2012/144</a></div></div><div id=ref-HomomorphicEncryptionSecurityStandard class=csl-entry role=listitem><div class=csl-left-margin>[7]</div><div class=csl-right-inline>M.
Albrecht <em>et al.</em>, <span>“Homomorphic encryption security
standard,”</span> HomomorphicEncryption.org; HomomorphicEncryption.org,
Toronto, Canada, 2018.</div></div><div id=ref-inferati_fhe_bgv class=csl-entry role=listitem><div class=csl-left-margin>[8]</div><div class=csl-right-inline>Inferati, <span>“Understanding fully
homomorphic encryption (FHE) schemes: BGV.”</span> <a href=https://www.inferati.com/blog/fhe-schemes-bgv class=uri>https://www.inferati.com/blog/fhe-schemes-bgv</a>,
2025.</div></div><div id=ref-attackondgs class=csl-entry role=listitem><div class=csl-left-margin>[9]</div><div class=csl-right-inline>F.
Aydin, E. Karabulut, S. Potluri, E. Alkim, and A. Aysu, <span>“RevEAL:
Single-trace side-channel leakage of the SEAL homomorphic encryption
library,”</span> in <em>2022 design, automation & test in europe
conference & exhibition (DATE)</em>, 2022, pp. 1527–1532. doi: <a href=https://doi.org/10.23919/DATE54114.2022.9774724>10.23919/DATE54114.2022.9774724</a>.</div></div><div id=ref-cachetiminattack class=csl-entry role=listitem><div class=csl-left-margin>[10]</div><div class=csl-right-inline>W.
Cheng, J.-L. Danger, S. Guilley, F. Huang, A. Bel Korchi, and O. Rioul,
<span>“<span class=nocase>Cache-Timing Attack on the SEAL Homomorphic
Encryption Library</span>,”</span> in <em><span class=nocase>11th
International Workshop on Security Proofs for Embedded Systems (PROOFS
2022)</span></em>, Leuven, Belgium, Sep. 2022. Available: <a href=https://telecom-paris.hal.science/hal-03780506>https://telecom-paris.hal.science/hal-03780506</a></div></div><div id=ref-attackonkeygen class=csl-entry role=listitem><div class=csl-left-margin>[11]</div><div class=csl-right-inline>F.
Aydin and A. Aysu, <span>“Leaking secrets in homomorphic encryption with
side-channel attacks.”</span> Cryptology <span>ePrint</span> Archive,
Paper 2023/1128, 2023. doi: <a href=https://doi.org/10.21203/rs.3.rs-3097727/v1>10.21203/rs.3.rs-3097727/v1</a>.</div></div><div id=ref-jasminwiki class=csl-entry role=listitem><div class=csl-left-margin>[12]</div><div class=csl-right-inline><span>“Jasmin project wiki.”</span> 2025.
Available: <a href=https://github.com/jasmin-lang/jasmin/wiki/>https://github.com/jasmin-lang/jasmin/wiki/</a></div></div><div id=ref-jasminkyber class=csl-entry role=listitem><div class=csl-left-margin>[13]</div><div class=csl-right-inline>J.
B. Almeida <em>et al.</em>, <span>“Formally verifying kyber episode v:
Machine-checked <span>IND</span>-<span>CCA</span> security and
correctness of <span>ML</span>-<span>KEM</span> in
<span>EasyCrypt</span>.”</span> Cryptology <span>ePrint</span> Archive,
Paper 2024/843, 2024. Available: <a href=https://eprint.iacr.org/2024/843>https://eprint.iacr.org/2024/843</a></div></div><div id=ref-Avanzi2017CRYSTALSKyberAS class=csl-entry role=listitem><div class=csl-left-margin>[14]</div><div class=csl-right-inline>R.
Avanzi <em>et al.</em>, <span>“CRYSTALS-kyber algorithm specifications
and supporting documentation,”</span> 2017. Available: <a href=https://api.semanticscholar.org/CorpusID:198992527>https://api.semanticscholar.org/CorpusID:198992527</a></div></div><div id=ref-cryptoeprint:2021/204 class=csl-entry role=listitem><div class=csl-left-margin>[15]</div><div class=csl-right-inline>A.
Kim, Y. Polyakov, and V. Zucca, <span>“Revisiting homomorphic encryption
schemes for finite fields.”</span> Cryptology <span>ePrint</span>
Archive, Paper 2021/204, 2021. Available: <a href=https://eprint.iacr.org/2021/204>https://eprint.iacr.org/2021/204</a></div></div><div id=ref-OpenFHE class=csl-entry role=listitem><div class=csl-left-margin>[16]</div><div class=csl-right-inline>A.
A. Badawi <em>et al.</em>, <span>“<span>OpenFHE</span>: Open-source
fully homomorphic encryption library.”</span> Cryptology ePrint Archive,
Paper 2022/915, 2022. Available: <a href=https://eprint.iacr.org/2022/915>https://eprint.iacr.org/2022/915</a></div></div><div id=ref-menezes1996handbook class=csl-entry role=listitem><div class=csl-left-margin>[17]</div><div class=csl-right-inline>A.
J. Menezes, J. Katz, P. C. van Oorschot, and S. A. Vanstone,
<em>Handbook of applied cryptography</em>. in Discrete mathematics and
its applications. CRC Press, 1996. Available: <a href="https://books.google.ch/books?id=MhvcBQAAQBAJ">https://books.google.ch/books?id=MhvcBQAAQBAJ</a></div></div><div id=ref-montgomery_reduction class=csl-entry role=listitem><div class=csl-left-margin>[18]</div><div class=csl-right-inline>P.
L. Montgomery, <span>“Modular multiplication without trial
division,”</span> <em>Mathematics of Computation</em>, vol. 44, no. 170,
pp. 519–521, 1985, Accessed: Jun. 05, 2025. [Online]. Available: <a href=http://www.jstor.org/stable/2007970>http://www.jstor.org/stable/2007970</a></div></div><div id=ref-cryptoeprint:2024/585 class=csl-entry role=listitem><div class=csl-left-margin>[19]</div><div class=csl-right-inline>A.
Satriawan, R. Mareta, and H. Lee, <span>“A complete beginner guide to
the number theoretic transform (<span>NTT</span>).”</span> Cryptology
<span>ePrint</span> Archive, Paper 2024/585, 2024. doi: <a href=https://doi.org/10.1109/ACCESS.2023.3294446>10.1109/ACCESS.2023.3294446</a>.</div></div><div id=ref-ntt_transform class=csl-entry role=listitem><div class=csl-left-margin>[20]</div><div class=csl-right-inline>P.
Longa and M. Naehrig, <span>“Speeding up the number theoretic transform
for faster ideal lattice-based cryptography.”</span> Cryptology
<span>ePrint</span> Archive, Paper 2016/504, 2016. Available: <a href=https://eprint.iacr.org/2016/504>https://eprint.iacr.org/2016/504</a></div></div><div id=ref-lattirust2025 class=csl-entry role=listitem><div class=csl-left-margin>[21]</div><div class=csl-right-inline>C.
Knabenhans, <span>“Lattirust.”</span> <a href=https://github.com/cknabs/lattirust class=uri>https://github.com/cknabs/lattirust</a>; GitHub, 2025.</div></div><div id=ref-dgs class=csl-entry role=listitem><div class=csl-left-margin>[22]</div><div class=csl-right-inline>M.
R. Albrecht and M. Walter, <span>“<span class=nocase>dgs</span>,
<span>D</span>iscrete <span>G</span>aussians over the
<span>I</span>ntegers,”</span> 2018. Available: <a href=https://bitbucket.org/malb/dgs>https://bitbucket.org/malb/dgs</a></div></div></div><section id=footnotes class="footnotes footnotes-end-of-document" role=doc-endnotes><hr><ol><li id=fn1><p>For efficiency reasons, <span class="math inline">n</span> is generally a power of 2.<a href=#fnref1 class=footnote-back role=doc-backlink>↩︎</a></p></li><li id=fn2><p>Generally, <span class="math inline">t \ll q_l</span><a href=#fnref2 class=footnote-back role=doc-backlink>↩︎</a></p></li><li id=fn3><p>In practice, it will be over <span class="math inline">\{q-1, 0, 1\}</span> as secret key’s coefficients
are also in <span class="math inline">\mathbb{Z}_{q}</span><a href=#fnref3 class=footnote-back role=doc-backlink>↩︎</a></p></li><li id=fn4><p>Equation (4) on Inferati’s blog post on BGV<span class=citation data-cites=inferati_fhe_bgv><a href=#ref-inferati_fhe_bgv role=doc-biblioref>[8]</a></span> shows
the complete development.<a href=#fnref4 class=footnote-back role=doc-backlink>↩︎</a></p></li><li id=fn5><p>In our single modulus implementation, the values are
hardcoded manually in the file.<a href=#fnref5 class=footnote-back role=doc-backlink>↩︎</a></p></li><li id=fn6><p>Due to macOS adding an extra ‘_’, we implemented the
function a second time starting with only one ‘_’ instead of two.<a href=#fnref6 class=footnote-back role=doc-backlink>↩︎</a></p></li><li id=fn7><p>Negative index are not possible, thus we add <span class="math inline">{+\beta}</span> to all the index.<a href=#fnref7 class=footnote-back role=doc-backlink>↩︎</a></p></li></ol></section></body></html><hr><div class=footer><a class=previous-post href="/writings/type-confusions/type-confusions/?ref=footer"><span style=font-weight:700>«
Previous</span><br>Building a robust test suite of type confusion...</a></div></div></main><div class=article-toc><div class=toc-wrapper><h4 id=contents></h4><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#preliminaries>Preliminaries</a><ul><li><a href=#regev-encryption-scheme>Regev encryption scheme</a></li><li><a href=#bgv-encryption-scheme>BGV encryption scheme</a></li><li><a href=#side-channel-attacks>Side-channel attacks</a></li><li><a href=#projects-description>Project’s description</a></li></ul></li><li><a href=#technical-section>Technical Section</a><ul><li><a href=#from-kyber-implementation-to-bgv>From KYBER implementation to BGV</a></li><li><a href=#set-up>Set up</a></li><li><a href=#basic-polynomial-operations>Basic polynomial operations</a></li><li><a href=#barrett-reduction>Barrett Reduction</a></li><li><a href=#montgomery-reduction>Montgomery Reduction</a></li><li><a href=#ntt-amp-intt>NTT & INTT</a></li><li><a href=#sampling-randoms-polynomial>Sampling randoms polynomial</a></li><li><a href=#clients-protocol>Client’s protocol</a></li></ul></li><li><a href=#result>Result</a><ul><li><a href=#methodology>Methodology</a></li><li><a href=#benchmark>Benchmark</a></li><li><a href=#jasmin-takeaway>Jasmin Takeaway</a></li></ul></li><li><a href=#future-work>Future Work</a><ul><li><a href=#easycrypt-extraction-and-proving-constant-timeness>Easycrypt extraction and proving constant-timeness</a></li><li><a href=#rust-wrapper-extension>Rust Wrapper extension</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#references>References</a></li></ul></nav></div></div></div></body></html>